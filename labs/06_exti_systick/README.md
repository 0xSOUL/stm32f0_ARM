## Задание 06 "exti_systick"

В этом задании предлагается подключить энкодер для управления семисегментным индикатором.

## EXTI и кнопка

Прежде чем переходить к энкодеру вам предлагается поработать с модулем EXTI на более простом примере. 
Возьмите за основу пустой проект и добавьте функцию инициализации системы тактирования `rcc_config`,
которую можно взять из прошлых заданий. Далее необходимо вызвать её в `main`.
Также добавьте следующий список заголовочных файлов:

```c
#include "stm32f0xx_ll_rcc.h"
#include "stm32f0xx_ll_system.h"
#include "stm32f0xx_ll_bus.h"
#include "stm32f0xx_ll_gpio.h"
#include "stm32f0xx_ll_exti.h"
```

Файл `stm32f0xx_ll_exti.h` необходим для работы с модулем внешних прерываний. Заголовочные файлы `stm32f0xx_ll_utils.h` и `stm32f0xx_ll_cortex.h` нужны для работы с системным таймером. 

Напишите программу, которая будет переключать состояние светодиода при нажатии на кнопку, используя внешнее прерывание. Воспользуйтесь кнопкой, подключенной ко входу `0` порта `GPIOA`. Данная кнопка установлена на отладочной плате с надписью `USER`.

В первую очередь проинициализируйте линию `0` модуля `EXTI`. Для этого необходимо сконфигурировать мультиплексор выбора порта для линии `0` в регистрах `SYSCFG` (стр. 214 [справочного описание периферии](https://github.com/edosedgar/stm32f0_ARM/blob/master/docs/stm32f0xx_rm.pdf)).
Инициализацию выполните в функции `exti_config`:

```c
/*
 * Не забудьте про тактирование!
 */
LL_APB1_GRP2_EnableClock(LL_APB1_GRP2_PERIPH_SYSCFG);
/*
 * Подключение порта GPIOA для линии 0
 */
LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTA, LL_SYSCFG_EXTI_LINE0);
```

Далее включите обработку нулевой линии в модуле `EXTI`:

```c
LL_EXTI_EnableIT_0_31(LL_EXTI_LINE_0);
```

После этого настройте по какому фронту сигнал будет обрабатываться: нарастающему или спадающему, или по обоим. Кнопка имеет
подтягивающий резистор на землю, поэтому при нажатии будет генерировать нарастающий фронт.

```c
LL_EXTI_EnableRisingTrig_0_31(LL_EXTI_LINE_0);
```

Последним шагом сконфигурируйте линию прерывания `EXTI0_1_IRQn` в модуле `NVIC`:

```c
NVIC_EnableIRQ(EXTI0_1_IRQn);
NVIC_SetPriority(EXTI0_1_IRQn, 0);
```

Добавьте вызов данной функции в `main`. Напишите обработчик для внешнего прерывания:

```c
void EXTI0_1_IRQHandler(void)
{
    //
}
```

В данном обработчике добавьте переключение состояние вывода, подключенного к светодиоду (перед этим напишите функцию `gpio_config` для инициализации вывода). Не забудьте сбросить флаг 
для нулевой линии прерывания с помощью ` LL_EXTI_ClearFlag_0_31(LL_EXTI_LINE_0)`, иначе программа никогда не вернется в основной цикл программы. 

Заметьте, что на кнопке присутствует дребезг и поведение программы не всегда корректно.

## Системный таймер

Чтобы решить проблему с антидребезгом, используйте таймер для отчета времени. В первую очередь добавьте заголовочные файлы `stm32f0xx_ll_utils.h` и `stm32f0xx_ll_cortex.h` для работы с системным таймером.

Реализуйте функцию `systick_config`, где выполняется инициализация системного таймера. В первую очередь настройте предделитель, включите таймер и разрешите прерывание. Так как системный таймер является частью ядра, включать его в 
`NVIC` не нужно, включение производится непосредственно в регистре `SYST_CSR` c помощью метода `LL_SYSTICK_EnableIT`:

```c
/*
 * Частота 1 КГц (выставляются регистр-перезагрузка SYST_RVR и производится
 * включение таймера в SYST_CSR)
 * Входные параметры для функции это текущая частота МК и желаемая частота таймера
 */
LL_InitTick(48000000, 1000);
/*
 * Разрешение прерываний в модуле таймера в SYST_CSR
 */
LL_SYSTICK_EnableIT();

/*
 * В данном случае приоритет будет выставлен через регистр SCB, а не регистры NVIC, так как
 * номер прерываний -1 (системное прерывание)
 */
NVIC_SetPriority(SysTick_IRQn, 0);
```

Добавьте обработчик для таймера:

```c
void SysTick_Handler(void)
{
    //
}
```

Обработчик вызывается каждую миллисекунду. Чтобы помигать светодиодом, используя таймер, добавьте переключение в данном обработчике. Дополнительно добавьте переменную-счетчик, чтобы снизить частоту мерцания с 1 Кгц до 1 Гц.
Теперь светодиод мигает псевдопараллельно исполнению основного цикла `main`.

После проверки роботоспособности таймера, создайте глобальную переменную `milliseconds` и инкрементируйте ее значение в обработчике.

Вернитесь к обработчику внешнего прерывания. Чтобы реализовать антидребезг, создайте две переменные с текущим значением времени в мс и предыдущим значением. Каждый раз в обработчике проверяйте разницу между предыдущим и текущим временем, если больше 50 мс, значит можно считать, что кнопка была нажата:

```c
void EXTI0_1_IRQHandler(void)
{
    int ms = milliseconds;
    static ms_old = 0;
    
    /*
     * Если разница больше чем 50 между ms_old и ms, то выполнить действие
     */
     
    /* 
     * Обновить значение old_ms и сбросить флаг нулевой линии прерывания
     */
    return;
}
```

Таким образом, задействуя таймер и внешнее прерывания, вам удалось обработать нажатие кнопки. При этом цикл `main` остался пустым.

## Энкодер

Изучив примеры работы с периферией `EXTI` и `SyTick`, напишите программу, которая меняет частоту мерцания светодиода в зависимости от поворотов энкодера.

Для определенности предлагается использовать инкрементальный энкодер с двумя выводами. Инкрементальный энкодер это линейное, либо вращательное электромеханическое устройство, имеющее два выхода: A и B, на которых генерируются импульсы при вращении ручки энкодера.

Инкрементальный энкодер не показывает абсолютное положение ручки энкодера, он только показывает изменения положения, учитывая направление.

<p align="center">
  <img width="600" src="https://github.com/edosedgar/stm32f0_ARM/wiki/encoder.png" alt="encoder.png"/>
  <p align="center"> Сигнал с энкодера <p align="center">
      
При вращении сгенерированные импульсы имеют разницу фаз в 90 градусов между выходами A и B. В любой момент времени разница в фазе будет либо положительная, либо отрицательная в зависимости от направления вращения. В таком случае, если вращение происходит по часовой стрелке, разница фаз будет +90 градусов. Если вращать энкодер против часовой стрелки, то разница фаз будет -90 градусов. Частота импульсов прямопропорциональна скорости вращения энкодера. На рисунке ниже представлен пример работы роторного инкрементального энкодера.

<p align="center">
  <img width="600" src="https://github.com/edosedgar/stm32f0_ARM/wiki/encoder_anim.gif" alt="encoder_anim.gif"/>
  <p align="center"> Работы энкодера <p align="center">
