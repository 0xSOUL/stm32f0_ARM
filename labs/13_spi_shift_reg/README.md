## Задание 13 "spi_shift_reg"

### Подключение и использование сдвигового регистра

Свиговый регистр - утройство, которое часто используется для увеличения количества периферии.

![Распиновка сдвигового регистра](https://github.com/leokondrashov/stm32f0_ARM/blob/master/docs/images/74HC595-PINOUT.jpg)

Принцип его работы: 

Внутри есть восьмибитный регистр. При появлении переднего фронта на входе тактирования(SH_CP) значение в нём свигаются на один бит влево, а на самый младший разряд подставляется значение с пина данных(DS) в этот момент. При появлении переднего фронта на пине защёлки(ST_CP) это состояние выводится на вывода Q0-Q7. 

Оставшиеся пины: Q7' - пин переноса (если захочется каскадно подключить несколько сдвиговых регистров один за другим) - оставляем недоключеннным. ~MR - пин очистки - притягиваем к земле; ~OE - пин отключения выходов - подтягиваем к питанию, так как они нам не понадобятся.

В этой лабораторной мы будем использовать в таком режиме: выдавать подряд 8 байт с тактированием, чтобы регистр их считывал, и только после этого подаём сигнал на защёлку. Такой режим использования можно реализовать, передавая байт через SPI. Для этого будут задействованы только выход тактирования(PA5) и выход MOSI(PA7). При этом, мы не используем ни в каком виде сигнал Chip Select - он нам не нужен. Так же нам понадобится отдельный сигнал для вывода сигналя на защёлку(PC4).

![Подключение сдвигового регистра](https://github.com/leokondrashov/stm32f0_ARM/blob/master/docs/images/74HC595-CONNECT.jpg)

Итого, подключение сдвигового регистра: PA5 к пину 12(SH_CP); PA7 к пину 14(DS); PC4 к пину 11(ST_CP); к пинам 15, 1-7(Q0-Q7) - светодиоды; 8(GND), 13(~OE) - к земле; 16(VCC), 10(~MR) - к питанию

### Инициализация

1. Инициализация пинов:

```c
    /*
     * Init latch pin
     */
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
    LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_4, LL_GPIO_MODE_OUTPUT);
    /*
     * Init GPIO pertained to SPI module
     */
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
    //SPI_MOSI
    LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_7, LL_GPIO_MODE_ALTERNATE);  //PA7
    LL_GPIO_SetAFPin_0_7(GPIOA, LL_GPIO_PIN_7, LL_GPIO_AF_0);
    LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_7, LL_GPIO_SPEED_FREQ_HIGH);
    //SPI_MISO
    LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_6, LL_GPIO_MODE_ALTERNATE);  //PA6 (unused)
    LL_GPIO_SetAFPin_0_7(GPIOA, LL_GPIO_PIN_6, LL_GPIO_AF_0);
    //SPI_SCK
    LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_5, LL_GPIO_MODE_ALTERNATE);  //PA5
    LL_GPIO_SetAFPin_0_7(GPIOA, LL_GPIO_PIN_5, LL_GPIO_AF_0);
    LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_5, LL_GPIO_SPEED_FREQ_HIGH);

```

Происходит инициализация PA5-PA7 на альтернативные функции (как интерфейсные пины для SPI). Выходы настраиваются на высокую скорость передачи

2. Инициализация SPI:

```c
    LL_APB1_GRP2_EnableClock(LL_APB1_GRP2_PERIPH_SPI1);
    LL_SPI_SetMode(SPI1, LL_SPI_MODE_MASTER); // Режим ведущего
    LL_SPI_SetBaudRatePrescaler(SPI1, LL_SPI_BAUDRATEPRESCALER_DIV8); // Частота 48MHz / 8 = 6MHz
    LL_SPI_SetTransferBitOrder(SPI1, LL_SPI_MSB_FIRST); // Старшие биты вперёд
    LL_SPI_SetDataWidth(SPI1, LL_SPI_DATAWIDTH_8BIT); // Пакеты по 8 бит
    LL_SPI_SetNSSMode(SPI1, LL_SPI_NSS_SOFT);
    LL_SPI_Enable(SPI1);

```

Про настройку NSS: 

Так как мы используем не полностью весь стандарт SPI, а именно: STM32 всегда ведущий и нам нет необходимости использовать Slave Select, то можно не использовать пин `SPI_NSS`. `SPI_NSS` - пин, который используется в случае, когда мы хотим получать такой сигнал (в режиме ведомого или multi-master режиме) или хотим вывести такой сигнал (в режиме ведущего, правда, только для одного ведомого). В нашем случае, мы работаем в режиме, когда этот пин отключен от SPI, и всё управление передано в руки кода (выставить/очистить бит SSI в конфигурационном регистре SPI)

### Вывод значения через SPI

Функция `hc595_set`:

```c
static void hc595_set(uint8_t byte)
{
    uint16_t counter = 1000;

    /*
     * Send the data
     */
    LL_SPI_TransmitData8(SPI1, byte);

    /*
     * Toggle latch pin
     */
    LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_4);
    while (counter--); // Небольшая задежка перед передним фронтом
    LL_GPIO_SetOutputPin(GPIOC, LL_GPIO_PIN_4);
    return;
}
```

Сначала передаём байт, а зетем должны организовать передний фронт на пине защёлки, чтобы состояние на выходе сдвигового регистра обновилось. Для этого выставляем пин в нуль, затем есть небольшая задержка, и только после неё выставляем единицу на выходе. Именно в этот момент обновится выходное состояние. Как можно заметить, на защёлке остаётся логическая единица: это никак не влияет на работу, так как защёлка срабатывает только по переднему фронту

### Использование

Использование происходит в обработчике прерываний системного таймера, который настроен так, чтобы генерировать прерывания 1000 раз в секунду. Сам вывод на экран происходит раз в 1000 прерываний, то есть каждую секунду, так же, как и обновление значения `led_status`

В данной конфигурации, светодиоды горят по череди. 

В качестве задания можно сделать так, чтобы первый светодиод мигал с одной частотой, второй - с в 2 раза меньшей, третий - в 4 раза меньшей и т.д. по степеням двойки. (Есть простое решение, для которого нужно изменить только одну строчку)
