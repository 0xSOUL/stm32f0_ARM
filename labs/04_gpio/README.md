## Задание 04 "gpio"

После ознакомления с устройством GPIO в микроконтроллере STM32 на лекции и [вспомогательной статье](https://github.com/edosedgar/stm32f0_ARM/wiki/GPIO-revisited), попробуйте выполнить несколько практических задач.

## Мигание светодиодом

На отладочной плате, используемой в курсе установлены два светодиода, подключенных к выводам 8 и 9 порта GPIOC.

Возьмите за основу пустой проект и добавьте функцию инициализации системы тактирования `rcc_config`, которую можно взять из прошлых заданий. Далее необходимо вызвать её в `main`.

Теперь необходимо подать тактирование на модуль порта GPIOC и настроить непосредственно выводы со светодиодами в режим **цифровой выход**. Имейте ввиду, что все порты ввода-вывода подключены к шине **AHB**. Для этого создайте функцию `gpio_config` и поместите в нее следующий код:

```c
LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_8, LL_GPIO_MODE_OUTPUT);
return;
```

Добавьте вызов данной функции в `main`. Заметьте, что конфигурацию выходного драйвера менять не нужно: вывод не имеет подтяжки, работает в PushPull режиме и имеет низкую скорость работы.

Теперь вернитесь в `main` и выполните переключение состояние 8-ого вывода в бесконечном цикле. Для изменения состояния используйте функции 
`LL_GPIO_SetOutputPin` и `LL_GPIO_ResetOutputPin` из главы LL GPIO библиотеки LL.

```c
LL_GPIO_SetOutputPin(GPIOC, LL_GPIO_PIN_8); LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_8);
```

Помните, что в данных функциях происходит доступ к регистру `BSRR`: запись единицы в младшие 16 бит приводит к установке конкретного вывода, запись единицы в старшие 16 бит приводит к сбросу заданного вывода. Его основным преимуществом по сравнению с `ODR` заключается в том, что запись нуля не приводит к каким-либо изменениям, в то время как запись нуля в `ODR` приводит к сбросу соответствующего вывода. 

Теперь добавьте задержку между вызовами функций сброса и установки выхода. Можно использовать ту же самую функцию `delay` из прошлых занятий. На самом деле высокая точность здесь не нужна, поэтому можно сделать функцию `delay`, написанную на C и состоящую из пустого цикла на `100000` итераций.

## Подключение кнопки

Следующим шагом напишите программу, которая будет переключать состояние светодиода при нажатии на кнопку. Воспользуйтесь кнопкой, подключенной ко входу `0` порта `GPIOA`. Данная кнопка установлена на отладочной плате с надписью `USER`.

В первую очередь включите тактирование порта `GPIOA` в функции `gpio_config`:

```c
LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
```

Следующим шагом необходимо активировать режим **цифровой вход** (который на самом деле активирован по умолчанию на всех пинах):

```c
LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_0, LL_GPIO_MODE_INPUT);
```

Вернитесь в основной цикл и напишите код, который будет опрашивать состояние кнопки каждый проход цикла. После первого нажатия светодиод должен загораться, после второго потухнуть.

Для опроса состояние кнопки необходимо считывать состояние регистра `IDR` с помощью функции из LL:

```c
// 1 - кнопка нажата; 0 - отжата
status = LL_GPIO_IsInputPinSet(GPIOA, LL_GPIO_PIN_0);
```

После реализации вы можете заметить, что схема работает не очень стабильно из-за дребезга контактов. Попробуйте решить проблему дребезга за счет выставления задержки в случае, если кнопка была нажата. Как и в случае с миганием светодиода, реализуйте задержку на 0.1 секунды и вставьте ее вызов внутрь условного оператора:

```c
if (PINA_0 == 1) {
    delay_0.1ms();
    if led is on then off else on;
}
```

Подумайте какие недостатки у данной реализации антидребезга. Предложите реализацию, которая была бы лишена данных недостатков (она была рассказана в конце лекции).

*ЗАМЕЧАНИЕ:* в данной задаче необходимо отлавливать именно момент переключение входного состояния,
то есть переключение с `0` в `1` (или наоборот). В приведенной выше реализации светодиод будет переключаться постоянно,
пока кнопка нажата. Ваша задача: предложить реализацию, лишенного данного недостатка.

## Семисегментный индикатор

Поработав с базовыми элементами, перейдем к подключению семисегментного индикатора (seven-segment display). Индикатор имеет примерно следующий вид:

<p align="center">
  <img width="400" src="https://github.com/edosedgar/stm32f0_ARM/wiki/seven_segment.jpg" alt="seven_segment.jpg"/>
  <p align="center"> Семисегментный индикатор <p align="center">

Устройство имеет 10 выводов, центральный вывод в каждом ряду это общий анод/катод в зависимости от типа индикатора. Остальные выводы подключаются непосредственно к каждому из сегментов a,b,c,d,e,f,g,dp(точка). 

На индикаторе присутствует маркировка, по которой можно найти на него описание, где будет указано какой вывод куда подключен. Для удобства можно составить таблицу с соответствиями выхода с буквой сегмента.

Теперь подключите индикатор к порту микроконтроллера. Для примера возьмите порт `GPIOB` и подсоедините индикатор по следующей схеме (не забудьте на каждый сегмент подключить последовательно резистор на каждый сегмент номиналом 200-300 Ом):

```
a - GPIOB PIN0
b - GPIOB PIN1
c - GPIOB PIN2
...
g - GPIOB PIN6
```

Катод/анод подключите к `GPIOB PIN7`. Настройте соответствующие выходы в режим **цифровой выход**.

Теперь чтобы отобразить цифру `1` необходимо подать на порт B значение `0x0006` (нужно помнить, что 7 выход порта должен быть в нуле для индикатора с общим катодом, и всегда в единице для индикатора с общим анодом). Убедитесь в этом (не забудьте подать тактирование на порт B):

```c
// Вариант для случая, если индикатор с общим катодом
LL_GPIO_WriteOutputPort(GPIOB, 0x0006);
// Вот так выглядела бы запись для индикатора с общим анодом
LL_GPIO_WriteOutputPort(GPIOB, 0xFF & ~0x0006);
```

Теперь напишите функцию, которая принимает на вход число для отображения (от `0` до `f`) и показывает его на индикаторе.

```c
void show_digit(digit)
{
    /* 
     * Выберите необходимый набор выходов в зависимости от числа на входе
     * (можно использовать массив):
     * uint12_t decoder[16] = {
     *     [0] =  LL_GPIO_PIN_0 | LL_GPIO_PIN_1 | LL_GPIO_PIN_2 | LL_GPIO_PIN_3 | \
     *            LL_GPIO_PIN_4 | LL_GPIO_PIN_5,
     *     [1] = ...
     *     ...
     *     [15] = ...
     * }
     * uint16_t out = decoder[digit];
     */
     
    /*
     * Настройте правильно состояние анода. Подумайте какими битовыми операциями
     * можно включить/выключить ТОЛЬКО 7 бит переменной out.
     * Для катода ситуация с точностью до наоборот.
     */
     
    LL_GPIO_WriteOutputPort(GPIOB, out);
    return;
}
```

Последним шагом сделайте счетчик по нажатию кнопки: при каждом нажатии цифра на экране инкрементируется (от `0` до `f`). Используйте усовершенственный метод для антидребезга.

## Динамическая индикация

Пришло время подключить несколько индикаторов и сделать счетчик входных импульсов. Импульсы в данном случае генерируются за счет нажатия на кнопку. 

Предположим, что необходимо подключить 4 индикатора к микроконтроллеру. Каждый индикатор имеет 8 выходов (7 на каждый из сегментов и 1 на точку) и один вывод для общего катода/анода. В наивной реализации необходимо было бы подключить каждый индикатор по отдельности, в сумме затрачивая `8*N + N = 9N` выходов (где `N` это количество индикаторов). Немало. Чтобы снизить количество используемых выводов, используется динамическая индикация, главный принцип которой заключается в использовании свойства инерционности глаза.

Подробное описание принципа динамической индикации можно почитать [тут](https://www.radiokot.ru/start/mcu_fpga/avr/15/).
Проще говоря можно сгруппировать одноименные сегменты (сегменты `a` для каждого индикатора объединяются в один) и, последовательно активируя аноды индикаторов, выводить цифры на устройство. Таким образом цифры появляются по очереди. Если поднять частоту переключения индикаторов, то можно получить "статическую" картину. То есть в конкретный момент времени будет гореть только **один** индикатор, а не все, как в предыдущем случае. Количество используемых выводов при этом снизится до `8+N`.

## Бегущая строка

## Идеальный антидребезг
